* *planet*: process executing Rubyk (Lua)
* *satellite*: graphical interface (Qt)
* *patch*: stores a processing definition with parameters (Lua)
* *prototype*: stores a prototype for a processing node (Lua)
* *view*: a view contains widget organization and behavior to control a planet from a satellite (QML).

h2. Rubyk files

h3. prototype file

A prototype file contains Lua code to define a "class". The file contains method definitions, class variables and default values.

Note that all data needs to be stored in "self" since the file definition is shared among all instances of this "class". Any global variable is shared with all instances.

h3. patch file (processing definition/settings)

A patch contains code to instanciate prototypes, setup links and change parameters.

Note that the "set" operation updates a node if it exists or creates a new node if the given name does not exist. With some tricks in the @_G@ environment table, a setup file can be used without changes as a new prototype (this enables sub-patch abstraction).

h3. reload

When running a patch or prototype file, we need to "update" existing objects instead of recreating them so that links and state are preserved. Adding new objects or updating existing ones is easy, but how do we delete links/objects/methods ?

A solution could be to mark these elements as dirty before the script reload and remove them if they are still dirty (not touched) after script execution. In order to do this, we could use a new environment table on each reload and simply move objects from the old table to the new one on "create/update". What is left in the old table should be deleted.

But how do we delete a node in Lua ? Since Lua uses garbage collection, we need to remove all references to the node. This means removing:

# links pointing to the node
# references in env tables (parent node, prototype)

And how do we update sub-patch links (sub-patch definitions do not have this problem since they are "live" through the metatable) ? For now, we consider that these elements are not updatable.

h2. runtime Lua

h3. prototype

In a script, the 'node' is a prototype created by Node.new. The prototype stores methods
and outlet/inlet definitions. The script is run in its own private environment. This means
that it is possible to create private methods but all state information should live inside
'self' or it will be shared across objects.

h3. instance

An instance is made of an empty table with the prototype as metamethod. The instance also
contains an empty 'outlets' list with a special index method to create outlets as needed. In
order to create an outlet, the list searches the prototype's outlet definitions.