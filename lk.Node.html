<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>lk.Node</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">



    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.css" rel="stylesheet">
    <link href="css/docs.css" rel="stylesheet">
  </head>

  <body>
    <div class="header">
      <div class="container">
        <div class='row'>
          <div class='span12'>
             <a href='http://lubyk.org'><img alt='lubyk logo' src='img/lubyk.png'/></a> <h1><a href='http://doc.lubyk.org'>Lubyk documentation</a></h1></a> 
          </div>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="row">

        <div class='span3 local-nav'>
          <ul class='nav nav-tabs nav-stacked affix'>
                        <li><a href='#Node'><i class='icon-chevron-right'></i> lk.Node</a></li>
                        <li><a href='#Title'><i class='icon-chevron-right'></i> Title</a></li>
                      </ul>
        </div>

        <div class='main span7'>

                    <section id='Node'>
          <h2 class='section'>lk.Node</h2>

                              <h4 id='setParam' class='entry method'><span>:</span>setParam <code>(k, value)</code></h4>
          
                    <p class='summary'></p>
                    <p>-- node metatable local lib   = {type='lk.Node'} lib.__index = lib <a href='lk.Node.html'>lk.Node</a>     = lib</p>
                    <p>-- node's environment metatable local env_mt= {} local private = {} local lubyk_mt = {} lubyk_mt.__index = lubyk_mt</p>
                    <p>setmetatable(lib, { __call = function(lib, ...) return lib.new(...) end })</p>
                    <p>local env  = {} -- new node local self = { -- Find inlet by name. Inlets not in slots.inlets are removed on GC. -- Do not change this field name: it is used by <a href='editor.Node.html'>editor.Node</a>. inlets  = setmetatable({}, {__mode = 'v'}), -- Find outlet by name. Outlets not in slots.outlets are removed on GC. -- Do not change this field name: it is used by <a href='editor.Node.html'>editor.Node</a>. outlets = setmetatable({}, {__mode = 'v'}), -- GC protection of inlets and outlets. Here the slots are ordered. slots = { inlets  = {}, outlets = {}, }, accessors = {}, env       = env, errors    = {}, name      = name, process   = process, } setmetatable(self, lib)</p>
                    <p>-- Table to declare and access outlets self.outlet_method = lk.OutletMethod(self)</p>
                    <p>-- env has read access to _G setmetatable(env, env_mt) env.lubyk = setmetatable({ -- Table to declare inlets. i = lk.InletMethod(self), -- Table to declare and access outlets. o = self.outlet_method, -- Table to declare and access parameters. p = lk.ParamMethod(self), -- Print to remote GUI print = function(...) self:log('info', ...) end, -- Log error or warning to GUI log = function(...) self:log(...) end,</p>
                    <pre class='prettyprint lang-lua'>-- PRIVATE
_node = self,</pre>
                    <p>}, lubyk_mt)</p>
                    <p>process.nodes[name] = self -- pending connection resolution self.pending_inlets = process.pending_nodes[name] or {} process.pending_nodes[name] = nil if code_str then self:eval(code_str) end return self end</p>
                    <p>-- metatable for the new global env in each -- node function env_mt.__index(env, name) -- if the variable exists in original _G, -- cache locally local gvar = _G[name] rawset(env, name, gvar) return gvar end</p>
                    <p>if self.parent then return self.parent:url() .. '/' .. self.name else return self.process:url() .. '/' .. self.name end end</p>
                    <p>-- function to reload code local code, err = loadstring(code_str, self:url()) if not code then self:error(err) return end</p>
                    <p>-- In case of error, we rollback local old_slots = self.slots</p>
                    <p>-- Reset list of GC protected slots. self.slots = { inlets  = {}, outlets = {}, }</p>
                    <p>-- Clear cached outlet functions self.outlet_method:clear()</p>
                    <p>local old_accessors = self.accessors self.accessors = {}</p>
                    <p>-- code will execute in node's environment setfenv(code, self.env) -- We use sched pcall to enable yield during code eval (to -- launch mimas for example). local ok, err = sched:pcall(code) if not ok then self.slots = old_slots self.accessors = old_accessors self:error(err) else self:log('info', 'Script OK') self.code = code_str -- Unused inlets and outlets will be collected by the GC. end self.process.need_cleanup = true end</p>
                    <p>if definition.code and definition.code ~= self.code then self:eval(definition.code) elseif definition.class then local code = self.process:findClass(definition.class)</p>
                    <pre class='prettyprint lang-lua'>if code then
  -- Once the prototype is resolved, we remove 'class' information.
  definition.class = nil
  definition.code  = code
  self:eval(code)
else
  -- FIXME: set error on Node
  error(string.format("Could not find source code for '%s'.", self:url()))
end</pre>
                    <p>elseif not self.code then -- Try to find code local code = self.process:findCode(self:url() .. '.lua' ) if code then self:eval(code) else -- FIXME: set error on Node error(string.format("Could not find source code for '%s'.", self:url())) end end</p>
                    <p>for k, v in pairs(definition) do if k == '_' then -- load params after evaluating script code (so that -- allowed params and inlets are defined). local params = definition._ if params then self:setParams(params) end elseif k == 'source' or k == 'links' then -- ignore (we want to run these in a specific order) else self[k] = v end end</p>
                    <p>if not ignore_links then local links = definition.links if links then self:setLinks(links) end end end</p>
                    <p>self:log('error', ...) end</p>
                    <p>local fmt = string.format local all = {...} local f = all[1] local msg = '' if type(f) == 'table' then if f.__tostring then msg = tostring(f) else msg = tostring(f) end elseif <a href='#all'>all</a> > 1 then for i, v in ipairs(all) do if i == 1 then msg = tostring(v) else msg = msg .. '\t'..tostring(v) end end else msg = tostring(f) end</p>
                    <p>self.process:notify { log = { url = self:url(), msg = msg, typ = typ, } } end</p>
                    <p>if string.match(url, '^/') then return url else return (self.parent or self.process):url() .. '/' .. url end end</p>
                    <p>function private:setLink(out_name, target_url, process) local outlet = self.outlets[out_name] if not outlet then self:error(string.format("Outlet name '%s' does not exist.", out_name)) else local slot, err = process:get(target_url, lk.Inlet) if slot == false then -- error self:error(err) elseif not slot then -- slot not found -- If the slot does not exist yet, make a draft to be used -- when the node creates the real inlet. slot, err = process:pendingInlet(target_url) if not slot then -- FIXME: store absolute path for 'target_url' in process pending list -- and resolve this list on node creation self:error(err) return end end -- connect to real or pending slot outlet:connect(slot) end end</p>
                    <p>function private:removeLink(out_name, target_url) print('REMOVE_LINK', out_name, target_url) local outlet = self.outlets[out_name] if outlet then outlet:disconnect(target_url) end end</p>
                    <p>local process = self.process for out_name, links in pairs(all_links) do if type(links) == 'string' then private.setLink(self, out_name, links, process) else for target_url, link_def in pairs(links) do if link_def then private.setLink(self, out_name, target_url, process) else private.removeLink(self, out_name, target_url) end end end end end</p>
                    <p>local function dumpSlots(list, links) local res = {} for _,slot in ipairs(list) do table.insert(res, slot:dump(links)) end return res end</p>
                    <p>return { name = self.name, hue  = self.hue, x    = self.x, y    = self.y, code = self.code, --- Params _    = private.dumpParams(self, true), inlets  = dumpSlots(self.slots.inlets), outlets = dumpSlots(self.slots.outlets), } end</p>
                    <p>local res = {} for k, v in pairs(data) do if k == '_' then res[k] = private.dumpParams(self, v) elseif k ~= 'inlets' and k ~= 'outlets' and k ~= 'name' then -- 'inlets' and 'outlets' should never be in the data res[k] = self[k] end end</p>
                    <p>if data.code or data.links then -- code changes can alter slots: dump them</p>
                    <pre class='prettyprint lang-lua'>res.has_all_slots = true
res.inlets  = dumpSlots(self.slots.inlets)
res.outlets = dumpSlots(self.slots.outlets, data.links)
res._       = private.dumpParams(self, true)</pre>
                    <p>end return res end</p>
                    <p>--- Node has been removed from patch, remove links and gc. -- self.fin = lk.Finalizer(function() --   print('<strong></strong><strong></strong><strong></strong><strong></strong><strong></strong><strong></strong><strong></strong><strong></strong><strong></strong>* DELETED', self.name) -- end) -- Disconnect all links for _, outlet in ipairs(self.slots.outlets) do outlet:disconnectAll() end -- Remove from notification center self.process:onNotify(self, nil) self.env = nil self.process.need_cleanup = true end</p>
                    <p>local defaults = {} self.defaults = defaults local env = self.env local accessors = self.accessors for k, v in pairs(hash) do if type(k) ~= 'string' then self:error("Default keys must be strings.") end if type(v) == 'table' then -- Transform foo = {x = 3} to -- 'foo.x' => accessor local base = env[k] if not base then base = {} env[k] = base end -- Only one level deep. for sk, sv in pairs(v) do if type(sk) ~= 'string' then self:error(string.format("Default in '%s' must be a string.", k)) end local pname = k .. '.' .. sk if not accessors[pname] then accessors[pname] = function(value) -- This is executed during setParams. local rbase = env[k] if rbase then rbase[sk] = value -- So that param dump sees this value. env._pdump[pname] = rbase[sk] end local recv = accessors[k] if recv then recv(rbase) end end end -- This is done just once to set default values. defaults[pname] = sv env[pname] = sv if base[sk] == nil then base[sk] = sv end end else defaults[k] = v if env[k] == nil then -- Do not overwrite current values on script reload. env[k] = v local recv = accessors[k] if recv then recv(v) end end end end end</p>
                    <p>local p_node, p_params = {}, {}</p>
                    <p>local function doSetParams() local self, params = p_node, p_params -- Prepare for partial dump local pdump    = {} self.pdump     = pdump self.pdump_params = params local env      = self.env -- Special pos.x accessors need to register -- set value in pdump directly. env._pdump     = pdump local accessors= self.accessors local defaults = self.defaults or {} if params == true then -- Query asked for a dump of the params. pdump = defaults else for k, value in pairs(params) do if not defaults[k] then -- Error notification: Invalid param. self:error(string.format("Trying to set invalid parameter '%s'.", k)) else env[k] = value local recv = accessors[k] if recv then recv(value) -- 'receive' might set _pdump directly pdump[k] = pdump[k] or env[k] else pdump[k] = value end end end end -- Call 'param.changed' function in env if -- it exists. local func = accessors.changed if func then func(params) end end</p>
                    <p>--- Receive control events: update setting. p_node, p_params = self, params local ok, err = pcall(doSetParams) if not ok then p_node:error(err) end end</p>
                    <p>--- Receive a single param change from a source inside the process so -- we need to notify. local defaults  = self.defaults or {} local accessors = self.accessors if not defaults[k] then -- Error notification: Invalid param. self:error(string.format("Trying to set invalid parameter '%s'.", k)) else self.env[k] = value local recv = accessors[k] if recv then recv(value) end -- Call 'param.changed' function in env if -- it exists. local func = accessors.changed if func then func({k = value}) end end self.process:notify { -- YUCK ! FIXME: Why don't we use an alternative messaging method with -- string urls: notify('/foo/bar/_/baz', value) ? nodes = { [self.name] = { _ = {[k] = value}, }, }, } end</p>
                    <p>function private:dumpParams(params) if params == self.pdump_params then -- Optimization, send partial dump back. return self.pdump else local defaults = self.defaults if defaults then local env = self.env local res = {} if params == true then -- Dump all for k, <em> in pairs(defaults) do res[k] = env[k] end else for k, </em> in pairs(params) do -- Invalid param ? if not defaults[k] then -- Mark as invalid res[k] = {} else res[k] = env[k] end end end return res else  return nil end end end</p>
                    <p>-- lubyk() function lubyk_mt:__call() return self.i, self.o, self.p, self.print end</p>
                    <p>function lubyk_mt:setParam(...) self._node.process:setParam(self, ...) end</p>
                    <p>function lubyk_mt:info() return { name = self.node.name, url = self.node:url(), } end</p>
                    <p>-- register a function that should be called if there is a -- notification function lubyk_mt:onNotify(callback) self._node.process:onNotify(self.node, callback) end</p>
                    <p>lib.DEFAULT_CODE = [=[ --[[------------------------------------------------------</p>
                              </section>
                    <section id='Title'>
          <h2 class='section'>Title</h2>

                    
                    <p>Summary</p>
                    <h4 class='sub-title'>Inlets</h4>
                    <table class='definition'>
  <tr><td class='key'>foo</td><td>does this.</td></tr>
  <tr><td class='key'>bar</td><td>does that.</td></tr>

</table>
                    <h4 class='sub-title'>Outlets</h4>
                    <table class='definition'>
  <tr><td class='key'>bang</td><td>does blah.</td></tr>

</table>
                              </section>
                  </div>

        <div class='span2 global-nav'>
          <ul class='nav nav-tabs nav-stacked'>
                        <li class='module'><a href='lk.html'><span></span>lk</a></li>
            
                        <li class=''><a href='lk.Client.html'>Client</a></li>
                        <li class=''><a href='lk.Command.html'>Command</a></li>
                        <li class=''><a href='lk.DavMorph.html'>DavMorph</a></li>
                        <li class=''><a href='lk.DavServer.html'>DavServer</a></li>
                        <li class=''><a href='lk.Debug.html'>Debug</a></li>
                        <li class=''><a href='lk.Dir.html'>Dir</a></li>
                        <li class=''><a href='lk.Doc.html'>Doc</a></li>
                        <li class=''><a href='lk.Environment.html'>Environment</a></li>
                        <li class=''><a href='lk.FileResource.html'>FileResource</a></li>
                        <li class=''><a href='lk.Finalizer.html'>Finalizer</a></li>
                        <li class=''><a href='lk.Inlet.html'>Inlet</a></li>
                        <li class=''><a href='lk.InletMethod.html'>InletMethod</a></li>
                        <li class=''><a href='lk.Lubyk.html'>Lubyk</a></li>
                        <li class=''><a href='lk.Morph.html'>Morph</a></li>
                        <li class='active'><a href='lk.Node.html'>Node</a></li>
                        <li class=''><a href='lk.Observer.html'>Observer</a></li>
                        <li class=''><a href='lk.Outlet.html'>Outlet</a></li>
                        <li class=''><a href='lk.OutletMethod.html'>OutletMethod</a></li>
                        <li class=''><a href='lk.ParamMethod.html'>ParamMethod</a></li>
                        <li class=''><a href='lk.Patch.html'>Patch</a></li>
                        <li class=''><a href='lk.Process.html'>Process</a></li>
                        <li class=''><a href='lk.ProcessWatch.html'>ProcessWatch</a></li>
                        <li class=''><a href='lk.Properties.html'>Properties</a></li>
                        <li class=''><a href='lk.RemoteProcess.html'>RemoteProcess</a></li>
                        <li class=''><a href='lk.Scheduler.html'>Scheduler</a></li>
                        <li class=''><a href='lk.SelectCallback.html'>SelectCallback</a></li>
                        <li class=''><a href='lk.Service.html'>Service</a></li>
                        <li class=''><a href='lk.ServiceBrowser.html'>ServiceBrowser</a></li>
                        <li class=''><a href='lk.Settings.html'>Settings</a></li>
                        <li class=''><a href='lk.Socket.html'>Socket</a></li>
                        <li class=''><a href='lk.Socket2.html'>Socket2</a></li>
                        <li class=''><a href='lk.StemCell.html'>StemCell</a></li>
                        <li class=''><a href='lk.SubClass.html'>SubClass</a></li>
                        <li class=''><a href='lk.TCPSocket.html'>TCPSocket</a></li>
                        <li class=''><a href='lk.Thread.html'>Thread</a></li>
                        <li class=''><a href='lk.TimeRef.html'>TimeRef</a></li>
                        <li class=''><a href='lk.Timer.html'>Timer</a></li>
                        <li class=''><a href='lk.UDPSocket.html'>UDPSocket</a></li>
                        <li class=''><a href='lk.WebServer.html'>WebServer</a></li>
                        <li class=''><a href='lk.core.html'>core</a></li>
                        <li class=''><a href='lk.crypto.html'>crypto</a></li>
                        <li class=''><a href='lk.more.html'>more</a></li>
                        <li class=''><a href='lk.util.html'>util</a></li>
                      </ul>
        </div>
      </div>
    </div>

    <footer class="footer">
    <div class="container">
       made with <a href='http://doc.lubyk.org/lk.Doc.html'>lk.Doc</a> 
    </div>
    </footer>

    <script src='https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?lang=lua&skin=default'></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        config: ["MMLorHTML.js"],
        jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML"],
        extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js"],
        TeX: {
          extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
        },
        menuSettings: {
          zoom: "Hover",
          mpContext: true,
          mpMouse: true
        },
      });
    </script>
    <script type="text/javascript"
      src='https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js'></script>
    <script src='http://code.jquery.com/jquery.js'></script>
    <script src='js/bootstrap.min.js'></script>
  </body>
</html>

