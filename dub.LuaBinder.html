<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>dub.LuaBinder</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">



    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.css" rel="stylesheet">
    <link href="css/docs.css" rel="stylesheet">
  </head>

  <body>
    <div class="header">
      <div class="container">
        <div class='row'>
          <div class='span12'>
             <a href='http://lubyk.org'><img alt='lubyk logo' src='img/lubyk.png'/> <h1>Lubyk documentation</h1></a> 
          </div>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="row">

        <div class='span3'>
          <ul class='nav nav-tabs nav-stacked local-nav affix'>
                        <li><a href='#LuaBinder'><i class='icon-chevron-right'></i> dub.LuaBinder</a></li>
                      </ul>
        </div>

        <div class='main span7'>

                    <section id='LuaBinder'>
          <h2 class='section'>dub.LuaBinder</h2>

                              <a name='decisionTree'></a>
          <h4 class='method'><span>:</span>decisionTree <code>(list)</code></h4>
          
                    <p class='summary'></p>
                    <p>local format  = string.format local lib     = { type = 'dub.LuaBinder', SELF = 'self', -- By default, we try to access userdata in field 'super'. This is not -- slower then checkudata if the element passed is a userdata. TYPE<em>ACCESSOR = 'checksdata', -- By default does an strcmp to ensure correct attribute key. ASSERT</em>ATTR<em>KEY = true, LUA</em>STACK<em>SIZE</em>NAME = 'LuaStackSize', CHECK<em>TO</em>NATIVE = { -- default is to use the same type (number = 'number') int        = 'number', }, TYPE<em>TO</em>CHECK = { double       = 'number', float        = 'number', size<em>t       = 'int', int          = 'int', uint         = 'int', uint8        = 'int', uint16       = 'int', uint32       = 'int', int8</em>t       = 'int', int16<em>t      = 'int', int32</em>t      = 'int', uint8<em>t      = 'int', uint16</em>t     = 'int', uint32_t     = 'int', char         = 'int', short        = 'int', LuaStackSize = 'int', ['unsigned char']  = 'int', ['signed int']     = 'int', ['unsigned int']   = 'int', ['signed short']   = 'int', ['unsigned short'] = 'int',</p>
                    <pre class='prettyprint lang-lua'>bool       = 'boolean',

['char *'] = 'string',
['unsigned char *'] = 'string',
['std::string'] = {
  type   = 'std::string',
  -- Get value from Lua.
  pull   = function(name, position, prefix)
    return format('size_t %s_sz_;\nconst char *%s = %schecklstring(L, %i, &%s_sz_);',
                  name, name, prefix, position, name)
  end,
  -- Push value in Lua
  push   = function(name)
    return format('lua_pushlstring(L, %s.data(), %s.length());', name, name)
  end,
  -- Cast value
  cast   = function(name)
    return format('std::string(%s, %s_sz_)', name, name)
  end,
},</pre>
                    <p>}, -- Native Lua operators LUA<em>NATIVE</em>OP = { add   = true, sub   = true, unm   = true, mul   = true, div   = true, eq    = true, lt    = true, le    = true, call  = true, index = true, }, -- Lua type constants NATIVE<em>TO</em>TLUA = { number  = 'LUA<em>TNUMBER', boolean = 'LUA</em>TBOOLEAN', }, -- Relative path to copy dub headers and cpp files. Must be -- relative to the bindings output directory. COPY<em>DUB</em>PATH  = '', COMPILER       = 'g++', COMPILER<em>FLAGS = { macosx = '-g -Wall -Wl,-headerpad</em>max<em>install</em>names -flat<em>namespace -undefined suppress -dynamic -bundle -fPIC', linux  = '-g -Wall -Wl,-headerpad</em>max<em>install</em>names -shared -fPIC', } } local private = {} lib.<em></em>index   = lib <a href='dub.LuaBinder.html'>dub.LuaBinder</a> = lib</p>
                    <p>--=============================================== dub.LuaBinder() setmetatable(lib, { <em></em>call = function(lib, options) local self = { options         = options or {}, extra<em>headers   = {}, custom</em>bindings = {}, } self.header_base = {'^'..lfs.currentdir()..'/(.*)$'} return setmetatable(self, lib) end })</p>
                    <p>--=============================================== PUBLIC METHODS -- Add xml headers to the database self.options = options if options.header<em>base then if type(options.header</em>base) == 'string' then options.header<em>base = {options.header</em>base} end self.header<em>base = {} for i, base in ipairs(options.header</em>base) do self.header<em>base[i] = '^'..lk.absolutizePath(base)..'/(.*)$' end end self.extra</em>headers = {} private.parseExtraHeadersList(self, nil, options.extra_headers)</p>
                    <p>local namespace<em>name = options.namespace or options.single</em>lib if namespace<em>name then self.namespace = inspector:find(namespace</em>name) end if options.single<em>lib then -- default is to: --   <strong> prefix mt types with lib name if we do not have a namespace --   </strong> not prefix if we have a namespace if self.namespace then -- in a namespace. Leave lib</em>prefix to nil or false. else if options.lib<em>prefix == false then options.lib</em>prefix = nil else options.lib<em>prefix = options.lib</em>prefix or options.single_lib end end end</p>
                    <p>if options.lib<em>prefix then -- This is the root of all classes. inspector.db.name = options.lib</em>prefix end</p>
                    <p>self.output<em>directory = self.output</em>directory or options.output_directory</p>
                    <p>if options.custom<em>bindings then self:parseCustomBindings(options.custom</em>bindings) end</p>
                    <p>self.ins = inspector local bound = {} if options.only then for <em>,name in ipairs(options.only) do local elem = inspector:find(name) if elem then table.insert(bound, elem) private.bindElem(self, elem, options) else print(string.format("Could not bind '%s' (not found).", name)) end end else local ignore = {} if options.ignore then for </em>, name in ipairs(options.ignore) do ignore[name] = true end end</p>
                    <pre class='prettyprint lang-lua'>private.bindAll(self, inspector, bound, ignore)</pre>
                    <p>end</p>
                    <p>if options.single<em>lib then private.makeLibFile(self, options.single</em>lib, bound) end private.copyDubFiles(self) end</p>
                    <p>local work<em>dir = opts.work</em>dir or lfs.currentdir() local files = '' for <em>, e in ipairs(opts.inputs) do files = files .. ' ' .. e end local flags = ' -I.' for </em>, e in ipairs(opts.includes or {}) do flags = flags .. ' -I' .. e end if opts.flags then flags = flags .. ' ' .. opts.flags end local cmd = 'cd ' .. work<em>dir .. ' && ' cmd = cmd .. self.COMPILER .. ' '  cmd = cmd .. self.COMPILER</em>FLAGS[Lubyk.plat] .. ' ' cmd = cmd .. flags .. ' ' cmd = cmd .. '-o ' .. opts.output .. ' ' cmd = cmd .. files if opts.verbose then print(cmd) end local pipe = io.popen(cmd) local res = pipe:read('*a') if res ~= '' then print(res) end end</p>
                    <p>--- Return a string containing the Lua bindings for a class. private.expandClass(self, class) if not self.class<em>template then -- path to current file local dir = lk.scriptDir() self.class</em>template = <a href='dub.Template.html'>dub.Template</a> {path = dir .. '/lua/class.cpp'} end return self.class_template:run {class = class, self = self} end</p>
                    <p>for k, v in pairs(list) do if type(v) == 'table' and not v.type then v.type = k end self.TYPE<em>TO</em>CHECK[k] = v end end</p>
                    <p>local strip = lk.strip if type(custom) == 'string' then -- This is a directory. Build table. local dir = lk.Dir(custom) custom = {} for yaml<em>file in dir:glob('%.yml') do -- Class or global function name. local elem</em>name = string.match(yaml<em>file, '([^/]+)%.yml$') local lua = yaml.load(lk.content(yaml</em>file)).lua for <em>, group in pairs(lua) do -- attributes, methods for name, value in pairs(group) do -- each attribute or method if type(value) == 'string' then -- strip last newline group[name] = {body = strip(value)} else for k, v in pairs(value) do value[k] = strip(v) end end end end custom[elem</em>name] = lua end end self.custom_bindings = custom or {} end</p>
                    <p>--- Create the body of the bindings for a given method/function. if not method then -- Just one parameter: global function. When creating method, we need the -- class because it could be a superclass method we are biding and thus the -- parent is not the correct one. method = parent parent = method.parent end</p>
                    <p>-- Resolve C++ types to native lua types. self:resolveTypes(method) local custom = private.customMetBinding(self, parent, method) local res = ''</p>
                    <p>if method.dtor then res = res .. format('DubUserdata <strong>userdata = ((DubUserdata</strong>)dub<em>checksdata</em>d(L, 1, "%s"));\n', self:libName(parent)) if custom and custom.body then res = res .. custom.body else res = res .. 'if (userdata->gc) {\n' res = res .. format('  %sself = (%s)userdata->ptr;\n', parent.create<em>name, parent.create</em>name) if custom and custom.cleanup then res = res .. '  ' .. string.gsub(custom.cleanup, '\n', '\n  ') end local dtor = parent.dub.destructor or method.parent.dub.destructor if dtor then res = res .. format('  self->%s();\n', dtor) else res = res .. '  delete self;\n' end res = res .. '}\n' res = res .. 'userdata->gc = false;\n' res = res .. 'return 0;' end else local param<em>delta = 0 if method.member then -- We need self res = res .. private.getSelf(self, parent, method, method.is</em>get<em>attr) param</em>delta = 1 end if method.has_defaults then -- We need arg count end</p>
                    <pre class='prettyprint lang-lua'>if method.is_set_attr then
  res = res .. private.switch(self, parent, method, param_delta, private.setAttrBody, parent.attributes)
elseif method.is_get_attr then
  res = res .. private.switch(self, parent, method, param_delta, private.getAttrBody, parent.attributes)
elseif method.is_cast then
  res = res .. private.switch(self, parent, method, param_delta, private.castBody, parent.superclasses)
elseif method.overloaded then
  local tree, need_top = self:decisionTree(method.overloaded)
  if need_top then
    res = res .. 'int top__ = lua_gettop(L);\n'
  end
  res = res .. private.expandTree(self, tree, parent, param_delta, '')
elseif method.has_defaults then
  res = res .. 'int top__ = lua_gettop(L);\n'
  local last, first = #method.params_list, method.first_default - 1
  for i=last, first, -1 do
    if i ~= last then
      res = res .. '} else '
    end
    if i == first then
      res = res .. '{\n'
    else
      res = res .. format('if (top__ &gt;= %i) {\n', param_delta + i)
    end
    res = res .. '  ' .. private.callWithParams(self, parent, method, param_delta, '  ', custom and custom['arg'..i], i) .. '\n'
  end
  res = res .. '}'
else
  res = res .. private.callWithParams(self, parent, method, param_delta, '', custom and custom.body)
end</pre>
                    <p>end return res end</p>
                    <p>--=============================================== PRIVATE</p>
                    <p>function private:callWithParams(class, method, param<em>delta, indent, custom, max</em>arg) local max<em>arg = max</em>arg or <a href='#method'>method</a>.params<em>list local res = '' for param in method:params() do if param.position > max</em>arg then break end res = res .. private.getParamVar(self, method, param, param<em>delta) end if custom then res = res .. custom if not string.match(custom, 'return[ ]+[^ ]') then res = res .. '\nreturn 0;' end else if method.array</em>get or method.array<em>set then local i</em>name = method.params<em>list[1].name res = res .. format('if (!%s || %s > %s) return 0;\n', i</em>name, i<em>name, method.array</em>dim) end if method.array<em>set then -- C array attribute set local i</em>name = method.params<em>list[1].name res = res .. 'self->' .. method.name .. '[' .. i</em>name .. '-1] = ' res = res .. private.paramForCall(method.params<em>list[2]) .. ';\n' res = res .. 'return 0;' else local call = private.doCall(self, class, method, max</em>arg) res = res .. private.pushReturnValue(self, class, method, call) end end return string.gsub(res, '\n', '\n' .. indent) end</p>
                    <p>function private:detectType(pos, type<em>name) local k = self.NATIVE</em>TO<em>TLUA[type</em>name] if k then return format('type<em></em> == %s', k), false else return format('dub<em>issdata(L, %i, "%s", type</em><em>)', pos, type</em>name), true end end</p>
                    <p>function private:expandTreeByType(tree, class, param<em>delta, indent, max</em>arg) local pos = tree.pos local res = '' local keys = {} local type<em>count = 0 for k, v in pairs(tree.map) do -- collect keys, sorted by native type first -- because they are easier to detect with lua</em>type if self.NATIVE<em>TO</em>TLUA[k] then table.insert(keys, 1, k) else table.insert(keys, k) end end local last<em>key = <a href='#keys'>keys</a> if last</em>key == 1 then -- single entry in decision, just go deeper return private.expandTreeByType(self, tree.map[keys[1]], class, param<em>delta, indent, max</em>arg) end</p>
                    <p>res = res .. format('int type<em></em> = lua<em>type(L, %i);\n', param</em>delta + pos) local ptr<em>for</em>pos = tree.ptr<em>for</em>pos if not ptr<em>for</em>pos then ptr<em>for</em>pos = {} tree.ptr<em>for</em>pos = ptr<em>for</em>pos end local clauses = {}</p>
                    <p>-- Parse types once to make sure we declare the ptri<em></em> pointers before -- we start using them in the type tests. for i, type<em>name in ipairs(keys) do if i == last</em>key then -- Never needed break end local clause, need<em>ptr = private.detectType(self, param</em>delta + pos, type<em>name) if need</em>ptr then local ptr<em>name = format('ptr%i</em><em>', param</em>delta + pos) if not ptr<em>for</em>pos[param<em>delta + pos] then ptr</em>for<em>pos[param</em>delta + pos] = ptr<em>name res = res .. format('void <strong></strong>%s;\n', ptr</em>name) end</p>
                    <pre class='prettyprint lang-lua'>  -- This ensures that we only use the ptr if there was a dub_issdata clause
  -- before (pointer is up-to-date).
  ptr_for_pos[format('%s-%i', type_name, param_delta + pos)] = ptr_name

  clauses[i] = format(' (%s = %s) ', ptr_name, clause)
else
  clauses[i] = clause
end</pre>
                    <p>end</p>
                    <p>for i, type<em>name in ipairs(keys) do local elem = tree.map[type</em>name] if i > 1 then res = res .. '} else ' end if i == last<em>key then res = res .. '{\n' else res = res .. format('if (%s) {\n', clauses[i]) end if elem.type == 'dub.Function' then -- done elem.ptr</em>for<em>pos = ptr</em>for<em>pos res = res .. '  ' .. private.callWithParams(self, class, elem, param</em>delta, '  ', nil, max<em>arg) .. '\n' else -- continue expanding res = res .. '  ' .. private.expandTreeByType(self, elem, class, param</em>delta, '  ', max_arg) .. '\n' end end res = res .. '}' return string.gsub(res, '\n', '\n' .. indent) end -- expandTreeByTyp</p>
                    <p>function private:expandTree(tree, class, param<em>delta, indent) local res = '' local keys = {} local type</em>count = 0 for k, v in pairs(tree.map) do -- cast to number local nb = k + 0 local done for i, ek in ipairs(keys) do -- insert biggest first if nb > ek then table.insert(keys, i, nb) done = true break end end if not done then -- insert at the end table.insert(keys, nb) end end</p>
                    <p>local last<em>key = <a href='#keys'>keys</a> if last</em>key == 1 then -- single entry in decision, just go deeper return private.expandTreeByType(self, tree.map[keys[1]..''], class, param_delta, indent) end</p>
                    <p>for i, arg<em>count in ipairs(keys) do local elem = tree.map[arg</em>count..''] if i > 1 then res = res .. '} else ' end if i == last<em>key then res = res .. '{\n' else res = res .. format('if (top</em><em> >= %i) {\n', param</em>delta + arg<em>count) end if elem.type == 'dub.Function' then -- done res = res .. '  ' .. private.callWithParams(self, class, elem, param</em>delta, '  ', nil, arg<em>count) .. '\n' else -- continue expanding res = res .. '  ' .. private.expandTreeByType(self, elem, class, param</em>delta, '  ', arg_count) .. '\n' end end res = res .. '}' return string.gsub(res, '\n', '\n' .. indent) end -- expandTree (by position)</p>
                    <p>local name = method.name local dname = method.dub.name if dname then -- This is to let users define custom binding name (overwrite '+' -- methods for example). return dname end if method.ctor then return 'new' elseif method.dtor then return '<em></em>gc' elseif method.is<em>set</em>attr then return '<em></em>newindex' elseif method.is<em>get</em>attr then return '<em></em>index' elseif string.match(name, '^operator') then local op = string.match(method.cname, '^operator<em>(.+)$') if self.LUA</em>NATIVE<em>OP[op] then return '</em>_' .. op else -- remove ending 'e' return string.sub(op, 1, -2) end elseif name == '' then -- ?? else return method.name end end</p>
                    <p>-- Return an iterator over the header of the element plus any -- extra header defined via 'extra<em>headers'. local headers if elem then local fullname = elem:fullname() headers  = self.extra</em>headers[fullname] or {} else headers = self.extra<em>headers['::'] or {} end local co = coroutine.create(function() -- Extra headers for </em>, h in ipairs(headers) do coroutine.yield(h) end if elem then -- Class header coroutine.yield(elem.header) else -- No element, binding library for h in self.ins.db:headers(self.bound<em>classes) do -- Iterates over all bound</em>classes, global functions and -- constants. coroutine.yield(h) end end end) return function() local ok, elem = coroutine.resume(co) if ok then return elem end end end --=============================================== Methods that can be customized</p>
                    <p>-- Output the header for a class by removing the current path -- or 'header<em>base', for </em>, base in ipairs(self.header_base) do local h = string.match(header, base) if h then return h end end return header end</p>
                    <p>if method:neverThrows() then return 'dub<em>checksdata</em>n' else return private.checkPrefix(self, method) .. self.TYPE_ACCESSOR end end</p>
                    <p>-- Return the 'public' name to use for the element in the -- bindings. This can be used to rename classes or namespaces. Instead -- of rewriting this method, users can also use the 'name<em>filter' option. local func = self.options.name</em>filter if func then return func(elem) else return elem.name end end</p>
                    <p>-- Return the 'lua<em>open' name to use for the element in the -- bindings. if not self.options.single</em>lib then return self:name(elem) else return string.gsub(self:libName(elem), '%.', '_') end end</p>
                    <p>-- Return the 'public' name to use for a constant. Instead of rewriting this -- method, users can also use the 'const<em>name</em>filter' option. local func = self.options.const<em>name</em>filter if func then return func(name) else return name end end</p>
                    <p>-- Return the 'public' name to use for an attribute. Instead of rewriting this -- method, users can also use the 'attr<em>name</em>filter' option. local func = self.options.attr<em>name</em>filter if func then return func(elem) else return elem.name end end</p>
                    <p>-- default name for <a href='dub.MemoryStorage.html'>dub.MemoryStorage</a> if not elem.name then return '_G' else local res = '' while elem and elem.name do if res ~= '' then res = '.' .. res end res = (self:name(elem) or elem.name) .. res elem = elem.parent end return res end end</p>
                    <p>local rtype = parent.db:resolveType(parent, ctype.name)</p>
                    <p>if rtype and rtype.type == 'dub.Class' then -- userdata local mt<em>name = self:libName(rtype) return { type = 'userdata', -- Resolved type rtype   = rtype, mt</em>name = mt_name, } else -- If the database cannot resolve type, use provided ctype. rtype = rtype or ctype</p>
                    <pre class='prettyprint lang-lua'>-- Is it a native lua type ?
local check
if ctype.ptr then
  check = self.TYPE_TO_CHECK[rtype.name..' *']
else
  check = self.TYPE_TO_CHECK[rtype.name]
end
if check then
  if type(check) == 'table' then
    check.rtype = check
    return check
  else
    return {
      type  = self.CHECK_TO_NATIVE[check] or check,
      check = check,
      -- Resolved type
      rtype = rtype,
    }
  end
else
  -- Not a native type and not known to the db: treat as 
  -- an unknown userdata type.
  local mt_name = self:libName(ctype)
  if mt_name ~= 'void' and mt_name ~= 'lua_State' then
    if rtype.ptr then
      dub.warn(5, "Using unknown type '%s *' (parent = %s).", mt_name, parent and parent.name or '??')
    else
      dub.warn(5, "Using unknown type '%s' (parent = %s).", mt_name, parent and parent.name or '??')
    end
  end
  -- Cache userdata type
  ctype.rtype = ctype.rtype or {
    type = 'userdata',
    -- Resolved type
    rtype   = private.makeType(ctype.name .. ' *'),
    mt_name = mt_name,
  }
  return ctype.rtype
end</pre>
                    <p>end end</p>
                    <p>local dummy<em>to</em>string<em>method = { neverThrows = function() return true end, } local res = '' -- We need self res = res .. private.getSelf(self, class, dummy</em>to<em>string</em>method, false) if class.dub.string<em>format then local args = class.dub.string</em>args if type(args) == 'table' then args = lk.join(args, ', ') end res = res .. format("lua<em>pushfstring(L, \"%s: %%p (%s)\", %s, %s);\n", self:libName(class), class.dub.string</em>format, self.SELF, args) else local fmt if class.dub.destroy == 'free' then fmt = "lua<em>pushfstring(L, \"%s: %%p (full)\", %s);\n" else fmt = "lua</em>pushfstring(L, \"%s: %%p\", %s);\n" end res = res .. format(fmt, self:libName(class), self.SELF) end return res end</p>
                    <p>--=============================================== PRIVATE</p>
                    <p>-- if this method does never throw, we can use luaL<em>check... function private:checkPrefix(method) if self.options.exceptions == false or method:neverThrows() then return 'luaL</em>' else return 'dub<em>' end end --- Find the userdata from the current lua</em>State. The userdata can -- be directly passed as first parameter or it can be inside a table as -- 'super'. function private.getSelf(self, class, method, need<em>mt) local nmt local fmt = '%s%s = <strong>((%s</strong>)%s(L, 1, "%s"%s));\n' if need</em>mt then -- Type accessor should leave metatable on stack. nmt = ', true' else nmt = '' end return format(fmt, class.create<em>name, self.SELF, class.create</em>name, self:customTypeAccessor(method), self:libName(class), nmt) end</p>
                    <p>--- Prepare a variable with a function parameter. function private:getParamVar(method, param, delta) if param.ctype.create<em>name == 'lua</em>State <strong>' then if param.name == 'L' then return '' else return "lua<em>State </strong> ".. param.name .. ' = L;\n' end end local p = private.getParam(self, method, param, delta) local lua = param.lua local rtype = lua.rtype if lua.push then -- special push/pull type return p .. '\n' else -- native type return format('%s%s = %s;\n', rtype.create</em>name, param.name, p) end end</p>
                    <p>--- Resolve all parameters and return value for Lua bindings. if base.resolved<em>for == 'lua' then -- done return else base.resolved</em>for = 'lua' end if base.index<em>op then self:resolveTypes(base.index</em>op) end</p>
                    <p>local list = base.overloaded or {base} for <em>, method in ipairs(list) do local parent = method.parent local sign = '' assert(method.params</em>list) for i, param in ipairs(method.params<em>list) do if i > 1 then sign = sign .. ', ' end param.lua = self:luaType(parent, param.ctype) if param.lua.type == 'userdata' then sign = sign .. param.lua.rtype.name else sign = sign .. param.lua.type end end if method.return</em>value then method.return<em>value.lua = self:luaType(parent, method.return</em>value) end method.lua_signature = sign end end</p>
                    <p>-- Retrieve a parameter and detect native type/userdata in param. function private:getParam(method, param, delta) local lua = param.lua local ctype = param.ctype -- Resolved ctype local rtype = lua.rtype if lua.mt<em>name and method.ptr</em>for<em>pos then local ptr = method.ptr</em>for<em>pos[format('%s-%i', lua.mt</em>name, delta + param.position)] if ptr then -- Only use ptr once (the first entry return format('<strong>((%s</strong>)%s)', rtype.create_name, ptr) end end</p>
                    <p>if lua.type == 'userdata' then -- userdata type<em>method = self:customTypeAccessor(method) return format('<strong>((%s</strong>)%s(L, %i, "%s"))', rtype.create</em>name, type<em>method, param.position + delta, lua.mt</em>name) else -- native lua type local prefix = private.checkPrefix(self, method) if lua.pull then -- special accessor return lua.pull(param.name, param.position + delta, prefix) elseif rtype.cast then return format('(%s)%scheck%s(L, %i)', rtype.cast, prefix, lua.check, param.position + delta) else return format('%scheck%s(L, %i)', prefix, lua.check, param.position + delta) end end end</p>
                    <p>function private.paramForCall(param) local lua = param.lua local res = '' if lua.cast then -- Special accessor res = res .. lua.cast(param.name) elseif lua.type == 'userdata' then -- custom type if param.ctype.ptr then res = res .. param.name else res = res .. '*' .. param.name end else -- native type res = res .. param.name end return res end</p>
                    <p>function private:doCall(parent, method, max<em>arg) local max</em>arg = max<em>arg or <a href='#method'>method</a>.params</em>list local res if method.array<em>get then -- C array attribute get i</em>name = method.params<em>list[1].name res = method.name .. '[' .. i</em>name .. '-1]' else if method.ctor then res = string.sub(parent.create<em>name, 1, -3) .. '(' else res = method.name .. '(' end local first = true for param in method:params() do if param.position > max</em>arg then break end local lua = param.lua if not first then res = res .. ', ' else first = false end res = res .. private.paramForCall(param) end res = res .. ')' end if method.ctor then res = 'new ' .. res elseif method.member then res = self.SELF .. '->' .. res elseif parent.is_scope then res = parent.name .. '::' .. res end</p>
                    <p>return res; end</p>
                    <p>function private:pushReturnValue(class, method, value) local res = '' local return<em>value = method.return</em>value if return<em>value then if return</em>value.name == self.LUA<em>STACK</em>SIZE<em>NAME then res = res .. 'return ' .. value .. ';' else res = res .. private.pushValue(self, method, value, return</em>value) end else res = res .. value .. ';\n' res = res .. 'return 0;' end return res end</p>
                    <p>function private:pushValue(method, value, return<em>value) local res local lua = return</em>value.lua local ctype = return_value if lua.push then res = lua.push(value) elseif lua.type == 'userdata' then -- resolved value local rtype = lua.rtype local gc</p>
                    <pre class='prettyprint lang-lua'>if not ctype.ptr then
  -- Call return value is not a pointer. This should never happen with
  -- a type that uses a custom push method.
  assert(not rtype.dub or not rtype.dub.push,
    string.format("Types with @dub 'push' setting should not be passed as values (%s).", method:fullname()))
  if method.is_get_attr then
    if ctype.const then
      if self.options.read_const_member == 'copy' then
        -- copy
        res = format('dub_pushudata(L, new %s(%s), "%s", true);', rtype.name, value, lua.mt_name)
      else
        -- cast
        res = format('dub_pushudata(L, const_cast&lt;%s*&gt;(&%s), "%s", false);', rtype.name, value, lua.mt_name)
      end
    else
      res = format('dub_pushudata(L, &%s, "%s", false);', value, lua.mt_name)
    end
  elseif return_value.ref then
    -- Return value is a reference.
    if ctype.const then
      if self.options.read_const_member == 'copy' then
        -- copy
        res = format('dub_pushudata(L, new %s(%s), "%s", true);', rtype.name, value, lua.mt_name)
      else
        -- cast
        res = format('dub_pushudata(L, const_cast&lt;%s*&gt;(&%s), "%s", false);', rtype.name, value, lua.mt_name)
      end
    else
      -- not const ref
      res = format('dub_pushudata(L, &%s, "%s", false);', value, lua.mt_name)
    end
  else
    -- Return by value.
    if method.parent.dub and method.parent.dub.destroy == 'free' then
      res = format('dub_pushfulldata&lt;%s&gt;(L, %s, "%s");', rtype.name, value, lua.mt_name)
    else
      -- Allocate on the heap.
      res = format('dub_pushudata(L, new %s(%s), "%s", true);', rtype.name, value, lua.mt_name)
    end
  end
else
  -- Return value is a pointer.
  res = format('%s%sretval__ = %s;\n', 
    (ctype.const and 'const ') or '',
    rtype.create_name, value)
  if not method.ctor then
    res = res .. 'if (!retval__) return 0;\n'
  end
  local push_method = rtype.dub and rtype.dub.push
  local custom_push
  if push_method then
    custom_push = true
    push_method = 'retval__-&gt;'.. push_method
  else
    push_method = 'dub_pushudata'
  end
  if ctype.const then
    assert(not custom_push, string.format("Types with @dub 'push' setting should not be passed as const types (%s).", method:fullname()))
    if self.options.read_const_member == 'copy' then
      -- copy
      res = res .. format('%s(L, new %s(*retval__), "%s", true);',
                          push_method, rtype.name, lua.mt_name)
    else
      -- cast
      res = res .. format('%s(L, const_cast&lt;%s*&gt;(retval__), "%s", false);',
                          push_method, rtype.name, lua.mt_name)
    end
  else
    -- We should only GC in constructor.
    if method.ctor or (method.dub and method.dub.gc) then
      res = res .. format('%s(L, retval__, "%s", true);',
                          push_method, lua.mt_name)
    else
      res = res .. format('%s(L, retval__, "%s", false);',
                          push_method, lua.mt_name)
    end
  end
end</pre>
                    <p>else -- native type res = format('lua_push%s(L, %s);', lua.type, value) end if string.match(res, '^return ') then return res else return res .. '\nreturn 1;' end end</p>
                    <p>function private:copyDubFiles() local dub<em>path = self.COPY</em>DUB<em>PATH if dub</em>path then local base<em>path = self.output</em>directory .. dub<em>path os.execute(format("mkdir -p '%s'", base</em>path)) -- path to current file local dir = lk.scriptDir() local dub<em>dir = dir .. '/lua/dub' for file in lfs.dir(dub</em>dir) do local res = lk.content(dub<em>dir .. '/' .. file) lk.writeall(base</em>path .. '/dub/' .. file, res, true) end end end</p>
                    <p>-- function body to set a variable. function private:setAttrBody(class, method, attr, delta) local custom = private.customAttrBinding(self, class, attr) if custom and custom.set then if custom.set:match(';') then -- Full custom binding definition return custom.set else -- Alias to a function call local met = class:method(custom.set) or attr.parent:method(custom.set) assert(met, format("Custom attribute binding for '%s' but '%s' method not found.", attr.name, custom.set)) self:resolveTypes(met) return private.callWithParams(self, class, met, delta + 1, '') end end</p>
                    <p>local name = attr.name local res = '' local param = { name     = name, ctype    = attr.ctype, position = 2, } local lua = self:luaType(class, param.ctype) param.lua = lua local p = private.getParam(self, method, param, delta) if type(lua.cast) == 'function' then -- TODO: move this into getParam ? res = res .. p p = lua.cast(name) elseif lua.type == 'userdata' then -- custom type if not param.ctype.ptr then p = '*' .. p else -- protect from gc res = res .. format('dub_protect(L, 1, %i, "%s");\n', param.position + delta, param.name) end else -- native type end if attr.static then res = res .. format('%s::%s = %s;\n', attr.parent.name, name, p) else res = res .. format('self->%s = %s;\n', name, p) end res = res .. 'return 0;' return res end</p>
                    <p>-- function body to set a variable. function private:castBody(class, method, super, delta) if not super.should<em>cast then return end local name = super.create</em>name local res = '' res = res .. format('*retval<em></em> = static_cast<%s>(self);\n', name) res = res .. 'return 1;' return res end</p>
                    <p>-- function body to get a variable. function private:getAttrBody(class, method, attr, delta) if attr.ctype.const and self.options.read<em>const</em>member == 'no' then return nil end local custom = private.customAttrBinding(self, class, attr) if custom and custom.get then if custom.get:match(';') then -- Full custom binding definition return custom.get else -- Alias to a function call local met = class:method(custom.get) or attr.parent:method(custom.get) assert(met, format("Custom attribute binding for '%s' but '%s' method not found.", attr.name, custom.get)) self:resolveTypes(met) return private.callWithParams(self, class, met, delta, '') end end</p>
                    <p>local lua = self:luaType(class, attr.ctype) attr.ctype.lua = lua local accessor if attr.static then accessor = format('%s::%s', attr.parent.name, attr.name) else accessor = format('self->%s', attr.name) end return private.pushValue(self, method, accessor, attr.ctype) end</p>
                    <p>function private:switch(class, method, delta, bfunc, iterator) local res = '' -- get key local param = { name     = 'key', ctype    = private.makeType('const char <strong>'), position = 1, } param.lua = self:luaType(class, param.ctype) if method.index<em>op then -- operator[] res = res .. format('if (lua</em>type(L, %i) != LUA<em>TSTRING) {\n', delta + 1) method.index</em>op.name = 'operator[]' res = res .. '  ' .. private.callWithParams(self, class, method.index<em>op, delta, '  ') .. '\n' res = res .. '}\n' if not class:hasVariables() then res = res .. 'return 0;' return res else res = res .. '\n' end end res = res .. private.getParamVar(self, method, param, delta) if method.is</em>get<em>attr then res = res .. '// <self> "key" <mt>\n' res = res .. '// rawget(mt, key)\n' res = res .. 'lua</em>pushvalue(L, 2);\n' res = res .. '// <self> "key" <mt> "key"\n' res = res .. 'lua<em>rawget(L, -2);\n' res = res .. 'if (!lua</em>isnil(L, -1)) {\n' res = res .. '  // Found method.\n' res = res .. '  return 1;\n' res = res .. '} else {\n' res = res .. '  // Not in mt = attribute access.\n' res = res .. '  lua<em>pop(L, 2);\n' res = res .. '}\n' elseif method.is</em>cast then res = res .. 'void </strong><strong>retval<em></em> = (void</strong><strong>)lua_newuserdata(L, sizeof(void</strong>));\n' end</p>
                    <p>local filter</p>
                    <p>if method.is_cast then filter = function(elem) return self:libName(elem) end else filter = function(elem) return self:attrName(elem) end end</p>
                    <p>local filtered<em>iterator = function() local function new</em>iterator() for elem in iterator(class) do local name = filter(elem) if name then coroutine.yield(name) end end end return coroutine.wrap(new_iterator) end</p>
                    <p>-- get key hash local sz = dub.minHash(class, filtered<em>iterator) if not sz then -- get/set without any public variables but using -- suffix code else res = res .. format('int key</em>h = dub<em>hash(key, %i);\n', sz) -- switch res = res .. 'switch(key</em>h) {\n' for elem in iterator(class) do local lua<em>name = filter(elem) if lua</em>name then local body = bfunc(self, class, method, elem, delta) if body then res = res .. format('  case %s: {\n', dub.hash(lua<em>name, sz)) -- get or set value res = res .. format('    if (DUB</em>ASSERT<em>KEY(key, "%s")) break;\n', lua</em>name) res = res .. '    ' .. string.gsub(body, '\n', '\n    ') .. '\n  }\n' end end end res = res .. '}\n' end</p>
                    <p>local custom = self.custom<em>bindings[method.parent.name] or {} if method.is</em>set<em>attr then if custom.set</em>suffix then res = res .. custom.set<em>suffix else res = res .. 'if (lua</em>istable(L, 1)) {\n' -- <tbl> <'key'> <value> res = res .. '  lua<em>rawset(L, 1);\n' res = res .. '} else {\n' res = res .. '  luaL</em>error(L, KEY<em>EXCEPTION</em>MSG, key);\n' res = res .. '}\n' -- If <self> is a table, write there end elseif method.is<em>get</em>attr then if custom.get<em>suffix then res = res .. custom.get</em>suffix end end res = res .. 'return 0;' return res end</p>
                    <p>function private:bindAll(parent, bound, ignore) for elem in parent:children() do if elem.type == 'dub.Class' then if not ignore[elem.name] and not (elem.dub.bind == false) then table.insert(bound, elem) private.bindElem(self, elem, options) end elseif elem.type == 'dub.Namespace' then if not ignore[elem.name] then private.bindAll(self, elem, bound, ignore) end end end end</p>
                    <p>function private:bindElem(elem, options) if elem.type == 'dub.Class' then local path = self.output_directory .. <a href='lk.Dir.html#sep'>lk.Dir.sep</a> .. self:openName(elem) .. '.cpp' lk.writeall(path, self:bindClass(elem), true) end end</p>
                    <p>-- See lua<em>simple</em>test for the output of this tree. local res = {count = 0, map = {}} local need<em>top = false for </em>, func in ipairs(list) do self:resolveTypes(func) for i=func.min<em>arg</em>size, <a href='#func'>func</a>.params<em>list do need</em>top = private.insertByTop(self, res, func, i) or need<em>top end end return res, need</em>top end</p>
                    <p>function private:insertByTop(res, func, index) -- force string keys local top<em>key  = format('%i', index) local map      = res.map local list     = map[top</em>key] local need<em>top = false if list then -- we need to make decision on argument type if list.type == 'dub.Function' then local f = list list = {} map[top</em>key] = list private.insertByArg(self, list, f) end private.insertByArg(self, list, func, index) else map[top<em>key] = func res.count = res.count + 1 need</em>top = need<em>top or res.count > 1 end return need</em>top end</p>
                    <p>local function hasMorePositions(skip<em>index, max</em>index) for i=1,max<em>index do if not skip</em>index[i] then return true end end return false end -- Insert a function into the hash, using the argument at the given -- index to filter function private:insertByArg(res, func, max<em>index, skip</em>index) -- First try existing positions in res (only get type for a few positions). if not res.map then -- first element inserted res.map = func res.list = {func} return elseif max<em>index == 0 or skip</em>index and not hasMorePositions(skip<em>index, max</em>index) then dub.warn(1, "No more arguments to decide (index=%i, parent=%s, function=%s)", max<em>index, func.parent.name, func.name) dub.warn(1, func.name .. func.argsstring) for </em>, func in ipairs(res.list) do dub.warn(1, func.name .. func.argsstring) end return elseif res.map.type == 'dub.Function' then res.list = {res.map, func} else table.insert(res.list, func) end</p>
                    <p>-- Build a count of differences by available index [1,max<em>index] local diff = {} for </em>, func in ipairs(res.list) do for i=1,max<em>index do if skip</em>index and skip<em>index[i] then -- already used, cannot use again else local lua = func.params</em>list[i].lua local type<em>name = (lua.type == 'userdata' and lua.mt</em>name) or lua.type local d = diff[i..''] if not d then diff[i..''] = {position = i, count = 0, map = {}, weight = 0} d = diff[i..''] end local list = d.map[type<em>name] if not list then d.count = d.count + 1 if lua.type ~= 'userdata' then d.weight = d.weight + 1 end d.map[type</em>name] = func else if list.type == 'dub.Function' then list = {list, func} d.map[type<em>name] = list else table.insert(list, func) end end end end end -- Select best match local match for </em>, d in pairs(diff) do if not match then match = d elseif d.weight > match.weight then match = d elseif d.weight == match.weight and d.count > match.count then match = d end end</p>
                    <p>assert(match, func.name.. ' '.. func.header) if match.count < <a href='#res'>res</a>.list then local skip<em>index = skip</em>index or {} skip<em>index[match.position] = true for k, elem in pairs(match.map) do if elem.type == 'dub.Function' then -- OK else local map = {} for </em>, func in ipairs(elem) do private.insertByArg(self, map, func, max<em>index, skip</em>index) end match.map[k] = map end end end</p>
                    <p>res.pos = match.position res.map = match.map end</p>
                    <p>function private:makeLibFile(lib<em>name, list) if not self.lib</em>template then local dir = lk.scriptDir() self.lib<em>template = <a href='dub.Template.html'>dub.Template</a> {path = dir .. '/lua/lib.cpp'} end self.bound</em>classes = list -- lib is a namespace local lib = self.namespace if not lib then -- lib is the global environment. lib = self.ins.db end local res = self.lib<em>template:run { lib      = lib, lib</em>name = lib_name, classes  = list, self     = self, }</p>
                    <p>local openname = self.options.luaopen or lib<em>name local path = self.output</em>directory .. <a href='lk.Dir.html#sep'>lk.Dir.sep</a> .. openname .. '.cpp' lk.writeall(path, res, true) end</p>
                    <p>function private:parseExtraHeadersList(base, list) if not list then return end for k, elem in pairs(list) do if type(k) == 'number' then local extra<em>list = self.extra</em>headers[base or '::'] if not extra<em>list then extra</em>list = {} self.extra<em>headers[base or '::'] = extra</em>list end table.insert(extra_list, elem) elseif base then -- sub type private.parseExtraHeadersList(self, base..'::'..k, elem) else private.parseExtraHeadersList(self, k, elem) end end end</p>
                    <p>local function getCustomBinding(custom<em>bindings, parent, key, elem) -- 1. current class local custom = custom</em>bindings[parent.name] custom = custom and custom[key] custom = custom and custom[elem.name] if custom then return custom end -- 2. elem.parent custom = custom_bindings[elem.parent.name] custom = custom and custom[key] custom = custom and custom[elem.name] if custom then return custom end end</p>
                    <p>-- Try to find a custom attribute binding. Search order: -- 1. current class  (current class being bound: can be a sub-class) -- 2. attr.parent    (class where the attribute/pseudo-attribute is defined) function private:customAttrBinding(parent, attr) return getCustomBinding(self.custom_bindings, parent, 'attributes', attr) end</p>
                    <p>-- Try to find custom binding definitions. Search order: -- 1. current class   (current class being bound: can be a sub-class) -- 2. method.parent   (class/namespace/db where the method is defined) function private:customMetBinding(parent, method) return getCustomBinding(self.custom_bindings, parent, 'methods', method) end</p>
                    <p>-- Add extra methods and attributes as needed by settings in  -- custom<em>bindings. function private:expandClass(class) -- Merge pseudo attributes in class variables. local custom = self.custom</em>bindings[class.name] or {} local attrs = custom.attributes if attrs then local list = class.variables<em>list local cache = class.cache for name, </em> in pairs(attrs) do if not cache[name] then class.has<em>variables = true local attr = { type   = 'dub.PseudoAttribute', name   = name, parent = class, -- dummy type ctype = private.makeType('void'), } table.insert(list, attr) cache[name] = attr end end end <a href='dub.MemoryStorage.html#makeSpecialMethods'>dub.MemoryStorage.makeSpecialMethods</a>(class, self.custom</em>bindings) end</p>
                              </section>
                  </div>

        <div class='span2'>
          <ul class='nav nav-tabs nav-stacked'>
                        <li class='module'><a href='dub.html'>dub</a></li>
                                    <li><a href='dub.CTemplate.html'>CTemplate</a></li>
                        <li><a href='dub.Class.html'>Class</a></li>
                        <li><a href='dub.Function.html'>Function</a></li>
                        <li><a href='dub.Inspector.html'>Inspector</a></li>
                        <li class='active'><a href='dub.LuaBinder.html'>LuaBinder</a></li>
                        <li><a href='dub.MemoryStorage.html'>MemoryStorage</a></li>
                        <li><a href='dub.Namespace.html'>Namespace</a></li>
                        <li><a href='dub.OptParser.html'>OptParser</a></li>
                        <li><a href='dub.Template.html'>Template</a></li>
                      </ul>
        </div>
      </div>
    </div>

    <footer class="footer">
    <div class="container">
       made with <a href='http://doc.lubyk.org/lk.Doc.html'>lk.Doc</a> 
    </div>
    </footer>

    <script src='https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?lang=lua&skin=default'></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        config: ["MMLorHTML.js"],
        jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML"],
        extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js"],
        TeX: {
          extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
        },
        menuSettings: {
          zoom: "Hover",
          mpContext: true,
          mpMouse: true
        },
      });
    </script>
    <script type="text/javascript"
      src='https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js'></script>
    <script src='http://code.jquery.com/jquery.js'></script>
    <script src='js/bootstrap.min.js'></script>
  </body>
</html>

